// Generated by CoffeeScript 1.9.1
var CSON, Config, LoadFileFormats, coffee, confPath, execPath, fs, loadCSONFile, loadCoffeeScriptFile, loadDir, loader, path;

fs = require('fs');

path = require('path');

CSON = require('cson');

coffee = require('coffee-script');

execPath = process.cwd();

confPath = path.resolve(process.env.NODE_PATH + '/../config');

LoadFileFormats = ['json', 'js', 'coffee', 'cson'];

loadCoffeeScriptFile = function(file_path) {
  return coffee["eval"](fs.readFileSync(file_path).toString());
};

loadCSONFile = function(file_path) {
  return CSON.load(file_path);
};

loader = function(file_path) {
  var ext, parser;
  ext = path.parse(file_path).ext;
  parser = null;
  switch (ext) {
    case '.json':
      parser = require;
      break;
    case '.js':
      parser = require;
      break;
    case '.coffee':
      parser = loadCoffeeScriptFile;
      break;
    case '.cson':
      parser = loadCSONFile;
  }
  return parser(file_path);
};

loadDir = function(path_name) {
  var answer, config_names, directories, directory, file, file_path, files, i, j, k, len, len1, len2, list, name, names;
  answer = {};
  list = fs.readdirSync("" + path_name);
  files = (function() {
    var i, len, results;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      file = list[i];
      if (fs.statSync(path_name + "/" + file).isFile()) {
        results.push(file);
      }
    }
    return results;
  })();
  directories = (function() {
    var i, len, results;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      file = list[i];
      if (fs.statSync(path_name + "/" + file).isDirectory()) {
        results.push(file);
      }
    }
    return results;
  })();
  names = {};
  config_names = ((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = files.length; i < len; i++) {
      file = files[i];
      results.push(path.parse(path_name + "/" + file).name);
    }
    return results;
  })()).concat(directories);
  for (i = 0, len = config_names.length; i < len; i++) {
    name = config_names[i];
    if (names[name]) {
      throw new Error("Duplicate config object " + name);
    } else {
      names[name] = true;
    }
  }
  for (j = 0, len1 = files.length; j < len1; j++) {
    file = files[j];
    file_path = path.resolve(path_name, file);
    name = path.parse(file_path).name;
    answer[name] = loader(file_path);
  }
  for (k = 0, len2 = directories.length; k < len2; k++) {
    directory = directories[k];
    answer[directory] = loadDir(path.resolve(path_name, directory));
  }
  return answer;
};

Config = (function() {
  Config.prototype._load = function(mode) {
    return new Config(mode);
  };

  function Config(mode) {
    var format, i, key, len, loaded, tmp, val;
    mode || (mode = process.env.NODE_ENV);
    mode || (mode = "development");
    loaded = false;
    tmp = {};
    for (i = 0, len = LoadFileFormats.length; i < len; i++) {
      format = LoadFileFormats[i];
      if (fs.existsSync(confPath + "/" + mode + "." + format) && fs.statSync(confPath + "/" + mode + "." + format).isFile()) {
        if (loaded) {
          throw new Error("Duplicate config object " + name);
        }
        tmp = loader(confPath + "/" + mode + "." + format);
        loaded = true;
      }
    }
    if (fs.existsSync(confPath + "/" + mode) && fs.statSync(confPath + "/" + mode).isDirectory()) {
      if (loaded) {
        throw new Error("Duplicate config object " + name);
      }
      tmp = loadDir(confPath + "/" + mode);
      loaded = true;
    }
    if (!loaded) {
      console.error("config file dosen't exist");
    }
    for (key in tmp) {
      val = tmp[key];
      this[key] = val;
    }
  }

  return Config;

})();

module.exports = new Config;
